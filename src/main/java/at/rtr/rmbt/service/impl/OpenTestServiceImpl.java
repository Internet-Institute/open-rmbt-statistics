package at.rtr.rmbt.service.impl;

import at.rtr.rmbt.constant.Constants;
import at.rtr.rmbt.dto.*;
import at.rtr.rmbt.exception.InvalidFieldsException;
import at.rtr.rmbt.exception.InvalidImageTypeException;
import at.rtr.rmbt.exception.InvalidLanguageException;
import at.rtr.rmbt.mapper.OpenTestMapper;
import at.rtr.rmbt.repository.GeoAnalyticsRepository;
import at.rtr.rmbt.repository.OpenTestRepository;
import at.rtr.rmbt.request.CapabilitiesRequest;
import at.rtr.rmbt.request.ClassificationRequest;
import at.rtr.rmbt.request.QosRequest;
import at.rtr.rmbt.request.opentest.OpenTestSearchRequest;
import at.rtr.rmbt.response.*;
import at.rtr.rmbt.response.opentest.OpenTestDTO;
import at.rtr.rmbt.response.opentest.OpenTestSearchResponse;
import at.rtr.rmbt.service.*;
import at.rtr.rmbt.utils.QueryParser;
import at.rtr.rmbt.utils.smoothing.Smoothable;
import at.rtr.rmbt.utils.smoothing.SmoothingFunction;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.github.sett4.dataformat.xlsx.XlsxMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
public class OpenTestServiceImpl implements OpenTestService {

    private final CapabilitiesRequest CAPABILITIES = CapabilitiesRequest.builder()
            .rmbtHttp(false)
            .qos(QosRequest.builder().supportsInfo(false).build())
            .classification(ClassificationRequest.builder().count(3).build())
            .build();

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public final static int SMOOTHING_DATA_AMOUNT = 5;
    public final static boolean RETURN_SMOOTHED_SPEED_CURVES = false;
    public final int DEFAULTROWS = 100; //default number of rows (when max_results is not specified)
    private static final String CSV_FILENAME = "opentests.csv";
    private static final String XLSX_FILENAME = "opentests.xlsx";

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList("download_classification", "upload_classification", "ping_classification", "signal_classification"));
    private final OpenTestRepository openTestRepository;
    private final ImageExportService imageExportService;
    private final PingService pingService;
    private final RadioSignalService radioSignalService;
    private final LocationService locationService;
    private final GeoAnalyticsRepository geoAnalyticsRepository;
    private final OpenTestMapper openTestMapper;

    @Override
    public ResponseEntity<Object> searchOpenDataTests(OpenTestSearchRequest openTestSearchRequest) {
        final Set<String> additionalFields;
        final List<String> invalidElements = new ArrayList<>();
        final QueryParser qp = new QueryParser();
        qp.parseQuery(openTestSearchRequest);

        //calculate offset
        long offset = -1;
        if (Objects.nonNull(openTestSearchRequest.getCursor())) {//TODO: validate getParameters.getNames().contains("cursor")
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(openTestSearchRequest.getCursor());
        }

        //get maximal results-parameter
        long maxrows = DEFAULTROWS;
        if (Objects.nonNull(openTestSearchRequest.getMaxResults())) {//TODO: validate getParameters.getNames().contains("max_results")
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(openTestSearchRequest.getMaxResults());
        }

        //parse additional fields
//        if (getParameters.getNames().contains("additional_info") || getParameters.getNames().contains("additional_info[]")) {
        if (Objects.nonNull(openTestSearchRequest.getAdditionalInfo()) && !openTestSearchRequest.getAdditionalInfo().isEmpty()) {
            List<String> param = openTestSearchRequest.getAdditionalInfo();
            for (String field : param) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add("additional_info");
                }
            }
            additionalFields = new HashSet<>(param);
        } else {
            additionalFields = new HashSet<>();
        }

        String format = ObjectUtils.defaultIfNull(openTestSearchRequest.getFormat(), "json").toLowerCase();


        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            throw new InvalidFieldsException(invalidElements);
        }

        OpenTestSearchResponse openTestSearchResults = openTestRepository.getOpenTestSearchResults(qp, offset, maxrows, additionalFields);


        ResponseEntity.BodyBuilder representation = ResponseEntity.ok();

        //format, depending on output format
        try {
            if (format.equals("csv")) {
                CsvMapper cm = new CsvMapper();
                cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
                CsvSchema schema = CsvSchema.builder().setLineSeparator("\r\n").setUseHeader(true)
                        .addColumnsFrom(cm.schemaFor(OpenTestDTO.class)).build();
                return representation
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + CSV_FILENAME)
                        .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                        .body(cm.writer(schema).writeValueAsString(openTestSearchResults.getResults()));
            } else if (format.equals("xlsx")) {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                XlsxMapper mapper = new XlsxMapper();
                mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                CsvSchema schema = mapper.schemaFor(OpenTestDTO.class).withHeader();
                SequenceWriter sequenceWriter = mapper.writer(schema).writeValues(outputStream);
                sequenceWriter.writeAll(openTestSearchResults.getResults());
                sequenceWriter.flush();
                sequenceWriter.close();
                return representation
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + XLSX_FILENAME)
                        .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                        .body(outputStream.toByteArray());
            } else {
                ObjectMapper om = new ObjectMapper();
                om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                return representation
                        .contentType(new MediaType("application", "json", StandardCharsets.UTF_8))
                        .body(om.writer().writeValueAsString(openTestSearchResults));
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return ResponseEntity.badRequest().build();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return representation.build();
    }

    @Override
    public ResponseEntity<Object> retrievePng(String lang, String openTestUuid, String size) {
        final String uuid = openTestUuid.substring(1); //since the first letter is a 'O'

        if (!lang.equals("de") && !lang.equals("en")) {
            throw new InvalidLanguageException("invalid language");
        }

        if (!size.equals("forumlarge") && !size.equals("forumsmall") && !size.equals("thumbnail")) {
            throw new InvalidImageTypeException("invalid image type");
        }


        ImageGenerateDto imageGenerateDto = openTestRepository.getImageGenerateDto(lang, uuid, size);
        byte[] output = imageExportService.generateImage(imageGenerateDto);
        return ResponseEntity.ok()
                .contentType(new MediaType("image", "png"))
                .body(output);
    }

    @Override
    public OpenTestDetailsDtoResponse getOpenTestByUuid(String openTestUuid, String verbose, String sender, String deprecatedSender) {
        int verboseLevel = parseVerboseLevel(verbose);
        String formattedOpenTestUuid = openTestUuid;
        //openTestIDs are starting with "O"
        if (openTestUuid != null && openTestUuid.startsWith("O")) {
            formattedOpenTestUuid = openTestUuid.substring(1);
        }
        OpenTestDetailsDTO openTestDetailsDTO = openTestRepository.getOpenTestByUuid(formattedOpenTestUuid, verboseLevel);
        OpenTestDetailsDtoResponse dto = new OpenTestDetailsDtoResponse();
        if (Objects.nonNull(openTestDetailsDTO)) {
            openTestMapper.toOpenTestDetailsDTO(dto, openTestDetailsDTO);
            //classify download, upload, ping, signal
            dto.setDownloadClassification(Classification.classify(Classification.THRESHOLD_DOWNLOAD, dto.getDownloadKbit(), CAPABILITIES.getClassification().getCount()));
            dto.setUploadClassification(Classification.classify(Classification.THRESHOLD_UPLOAD, dto.getUploadKbit(), CAPABILITIES.getClassification().getCount()));
            dto.setPingClassification(Classification.classify(Classification.THRESHOLD_PING, Math.round(dto.getPingMs() * 1000000), CAPABILITIES.getClassification().getCount()));

            //classify signal accordingly
            if ((dto.getSignalStrength() != null || dto.getLteRsrp() != null)
                    && dto.getNetworkType() != null) { // signal available
                if (dto.getLteRsrp() == null) { // use RSSI
                    if (dto.getNetworkType().equals("WLAN")) { // RSSI for Wifi
                        dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_WIFI, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                    } else { // RSSI for Mobile
                        dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_MOBILE, dto.getSignalStrength(), CAPABILITIES.getClassification().getCount()));
                    }
                } else // RSRP for LTE
                    dto.setSignalClassification(Classification.classify(Classification.THRESHOLD_SIGNAL_RSRP, dto.getLteRsrp(), CAPABILITIES.getClassification().getCount()));
            } else { // no signal available
                dto.setSignalClassification(null);
            }


            //also load download/upload-speed-data, signal data and location data if possible

            // speed data
            ObjectMapper objectMapper = new ObjectMapper();
            SpeedItems speedItems = null;
            try {
                speedItems = objectMapper.readValue(openTestDetailsDTO.getSpeedItems(), SpeedItems.class);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }

            //graphs
            OpenTestGraphDTO graphs = new OpenTestGraphDTO();

            if (speedItems != null) {
                long lastTime = -1;
                final List<SpeedItems.SpeedItem> uploadList = speedItems.getAccumulatedSpeedItemsUpload();
                final List<SpeedItems.SpeedItem> downloadList = speedItems.getAccumulatedSpeedItemsDownload();
                List<SpeedGraphItemDTO> downloadSpeeds = new ArrayList<>();
                List<SpeedGraphItemDTO> uploadSpeeds = new ArrayList<>();

                if (!RETURN_SMOOTHED_SPEED_CURVES) {
                    SpeedGraphItemDTO obj;
                    for (SpeedItems.SpeedItem item : uploadList) {
                        obj = new SpeedGraphItemDTO();
                        final long time = Math.round((double) item.getTime() / 1e6);
                        if (time == lastTime)
                            continue;
                        obj.setTimeElapsed(item.getTime());
                        obj.setBytesTotal(item.getBytes());
                        uploadSpeeds.add(obj);
                        lastTime = time;
                    }
                    lastTime = -1;
                    for (SpeedItems.SpeedItem item : downloadList) {
                        obj = new SpeedGraphItemDTO();
                        final long time = Math.round((double) item.getTime() / 1e6);
                        if (time == lastTime)
                            continue;
                        obj.setTimeElapsed(item.getTime());
                        obj.setBytesTotal(item.getBytes());
                        downloadSpeeds.add(obj);
                        lastTime = time;
                    }
                } else {
                    final List<? extends Smoothable> smoothedUploadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, uploadList, SMOOTHING_DATA_AMOUNT);
                    final List<? extends Smoothable> smoothedDownloadList = SmoothingFunction.smooth(SmoothingFunction.CENTRAL_MOVING_AVARAGE, downloadList, SMOOTHING_DATA_AMOUNT);

                    lastTime = -1;

                    SpeedGraphItemDTO obj;
                    for (Smoothable item : smoothedUploadList) {
                        obj = new SpeedGraphItemDTO();
                        final long time = Math.round((double) item.getXValue() / 1000000);
                        if (time == lastTime)
                            continue;
                        obj.setTimeElapsed(time);
                        obj.setBytesTotal(item.getYValue());
                        uploadSpeeds.add(obj);
                    }

                    lastTime = -1;

                    for (Smoothable item : smoothedDownloadList) {
                        obj = new SpeedGraphItemDTO();
                        final long time = Math.round((double) item.getXValue() / 1e6);
                        if (time == lastTime)
                            continue;
                        obj.setTimeElapsed(time);
                        obj.setBytesTotal(item.getYValue());
                        downloadSpeeds.add(obj);
                    }
                }

                graphs.setDownload(downloadSpeeds);
                graphs.setUpload(uploadSpeeds);
            }

            //if verbose - also add raw json data
            if (speedItems != null && verboseLevel > 0) {
                Map<String, Map<Integer, List<SpeedItems.SpeedItem>>> rawJSON = speedItems.getRawJSONData();

                //threads
                Map<String, Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>>> threadwise = new HashMap<>();

                //phases
                for (String phase : rawJSON.keySet()) {

                    Map<String, List<SpeedGraphItemDTO.SpeedItemThreadwise>> threads = new HashMap<>();
                    threadwise.put(phase, threads);

                    for (int thread : rawJSON.get(phase).keySet()) {
                        List<SpeedGraphItemDTO.SpeedItemThreadwise> threadItems = new ArrayList<>();
                        threads.put(String.valueOf(thread), threadItems);

                        //speed items
                        for (SpeedItems.SpeedItem item : rawJSON.get(phase).get(thread)) {
                            SpeedGraphItemDTO.SpeedItemThreadwise measurement = new SpeedGraphItemDTO.SpeedItemThreadwise();
                            measurement.setBytesTotal(item.getBytes());
                            measurement.setTimeElapsed(item.getTime());
                            threadItems.add(measurement);
                        }
                    }
                }

                dto.setSpeedCurveThreadwise(threadwise);
            }

            //Ping
            List<PingGraphItemDTO> pingGraph = pingService.getPingGraph(UUID.fromString(formattedOpenTestUuid));
            graphs.setPing(pingGraph);

            //Load signal strength from database
            List<SignalGraphItemDTO> radioSignalGraph = radioSignalService.getRadioSignalGraph(openTestDetailsDTO.getTestUid(), UUID.fromString(formattedOpenTestUuid), openTestDetailsDTO.getClientTime().getTime());
            graphs.setSignal(radioSignalGraph);

            //Load gps coordinates from database
            LocationGraphDTO locGraph = locationService.getLocationGraph(openTestDetailsDTO.getTestUid(), openTestDetailsDTO.getClientTime().getTime());
            graphs.setLocation(locGraph.getLocations());

            dto.setSpeedCurve(graphs);

            //get movement during test
            TestDistance dist = geoAnalyticsRepository.getTestDistance(UUID.fromString(formattedOpenTestUuid));
            if ((dist != null) && (dist.getTotalDistance() > 0) && dist.getTotalDistance() <= Constants.RMBT_GEO_DISTANCE_DETAIL_LIMIT) {
                dto.setDistance(dist.getTotalDistance());
            }

        } else {
            dto.setError("invalid open-uuid");
        }
        return dto;
    }

    private Integer parseVerboseLevel(String verbose) {
        return Optional.ofNullable(verbose)
                .map(x -> {
                    try {
                        return Integer.parseInt(x);
                    } catch (NumberFormatException ex) {
                        log.info("invalid non-numberic verbosity level");
                    }
                    return null;
                })
                .orElse(0);
    }
}
