package at.rtr.rmbt.service.impl;

import at.rtr.rmbt.dto.ImageGenerateDto;
import at.rtr.rmbt.exception.InvalidFieldsException;
import at.rtr.rmbt.repository.OpenTestRepository;
import at.rtr.rmbt.request.opentest.OpenTestSearchRequest;
import at.rtr.rmbt.response.opentest.OpenTestDTO;
import at.rtr.rmbt.response.opentest.OpenTestSearchResponse;
import at.rtr.rmbt.service.ImageExportService;
import at.rtr.rmbt.service.OpenTestService;
import at.rtr.rmbt.utils.QueryParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.SequenceWriter;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.github.sett4.dataformat.xlsx.XlsxMapper;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.*;

@Service
@RequiredArgsConstructor
public class OpenTestServiceImpl implements OpenTestService {

    public final int DEFAULTROWS = 100; //default number of rows (when max_results is not specified)
    private static final String CSV_FILENAME = "opentests.csv";
    private static final String XLSX_FILENAME = "opentests.xlsx";

    //additional fields that the user is allowed to request
    private final HashSet<String> allowedAdditionalFields = new HashSet<>(Arrays.asList("download_classification", "upload_classification", "ping_classification", "signal_classification"));
    private final OpenTestRepository openTestRepository;
    private final ImageExportService imageExportService;

    @Override
    public ResponseEntity<Object> searchOpenDataTests(OpenTestSearchRequest openTestSearchRequest) {
        final Set<String> additionalFields;
        final List<String> invalidElements = new ArrayList<>();
        final QueryParser qp = new QueryParser();
        qp.parseQuery(openTestSearchRequest);

        //calculate offset
        long offset = -1;
        if (Objects.nonNull(openTestSearchRequest.getCursor())) {//TODO: validate getParameters.getNames().contains("cursor")
            //is always a valid LONG because it is checked with all other
            //parameters above
            offset = Long.parseLong(openTestSearchRequest.getCursor());
        }

        //get maximal results-parameter
        long maxrows = DEFAULTROWS;
        if (Objects.nonNull(openTestSearchRequest.getMaxResults())) {//TODO: validate getParameters.getNames().contains("max_results")
            //is always a valid LONG because it is checked with all other
            //parameters above
            maxrows = Long.parseLong(openTestSearchRequest.getMaxResults());
        }

        //parse additional fields
//        if (getParameters.getNames().contains("additional_info") || getParameters.getNames().contains("additional_info[]")) {
        if (Objects.nonNull(openTestSearchRequest.getAdditionalInfo()) && !openTestSearchRequest.getAdditionalInfo().isEmpty()) {
            List<String> param = openTestSearchRequest.getAdditionalInfo();
            for (String field : param) {
                if (!allowedAdditionalFields.contains(field)) {
                    invalidElements.add("additional_info");
                }
            }
            additionalFields = new HashSet<>(param);
        } else {
            additionalFields = new HashSet<>();
        }

        String format = ObjectUtils.defaultIfNull(openTestSearchRequest.getFormat(), "json").toLowerCase();


        //if there have been errors => inform the user
        if (invalidElements.size() > 0) {
            throw new InvalidFieldsException(invalidElements);
        }

        OpenTestSearchResponse openTestSearchResults = openTestRepository.getOpenTestSearchResults(qp, offset, maxrows, additionalFields);


        ResponseEntity.BodyBuilder representation = ResponseEntity.ok();

        //format, depending on output format
        try {
            if (format.equals("csv")) {
                CsvMapper cm = new CsvMapper();
                cm.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                cm.enable(CsvGenerator.Feature.STRICT_CHECK_FOR_QUOTING);
                CsvSchema schema = CsvSchema.builder().setLineSeparator("\r\n").setUseHeader(true)
                        .addColumnsFrom(cm.schemaFor(OpenTestDTO.class)).build();
                return representation
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + CSV_FILENAME)
                        .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                        .body(cm.writer(schema).writeValueAsString(openTestSearchResults.getResults()));
            } else if (format.equals("xlsx")) {
                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
                XlsxMapper mapper = new XlsxMapper();
                mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                CsvSchema schema = mapper.schemaFor(OpenTestDTO.class).withHeader();
                SequenceWriter sequenceWriter = mapper.writer(schema).writeValues(outputStream);
                sequenceWriter.writeAll(openTestSearchResults.getResults());
                sequenceWriter.flush();
                sequenceWriter.close();
                return representation
                        .header(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + XLSX_FILENAME)
                        .contentType(new MediaType("text", "csv", StandardCharsets.UTF_8))
                        .body(outputStream.toByteArray());
            } else {
                ObjectMapper om = new ObjectMapper();
                om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
                return representation
                        .contentType(new MediaType("application", "json", StandardCharsets.UTF_8))
                        .body(om.writer().writeValueAsString(openTestSearchResults));
            }
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return ResponseEntity.badRequest().build();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return representation.build();
    }

    @Override
    public ResponseEntity<Object> retrievePng(String lang, String openTestUuid, String size) {
        final String uuid = openTestUuid.substring(1); //since the first letter is a 'O'

        if (!lang.equals("de") && !lang.equals("en")) {
            throw new RuntimeException("invalid language");
        }

        ImageGenerateDto imageGenerateDto = openTestRepository.getImageGenerateDto(lang, uuid, size);
        byte[] output = imageExportService.generateImage(imageGenerateDto);
        return ResponseEntity.ok()
                .contentType(new MediaType("image", "png"))
                .body(output);
    }
}
