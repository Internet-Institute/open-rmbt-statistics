package at.rtr.rmbt.repository.impl;

import at.rtr.rmbt.repository.OpenTestStatisticsRepository;
import at.rtr.rmbt.utils.QueryParser;
import lombok.RequiredArgsConstructor;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.PreparedStatementSetter;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.stereotype.Repository;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

@Repository
@RequiredArgsConstructor
public class OpenTestStatisticsRepositoryImpl implements OpenTestStatisticsRepository {

    private final int[] intervalsMins = {
            5,
            30,
            60,
            12 * 60, //12h
            60 * 24, //24h
            60 * 24 * 7  //7d
    };
    private final Map<Integer, String> INTERVAL_LABELS_MAP = Map.of(5, "5min",
            30, "30min",
            60, "60min",
            12 * 60, "12h",
            60 * 24, "24h",
            60 * 24 * 7, "7d");
    private final JdbcTemplate jdbcTemplate;

    @Override
    public Map<String, Long> calculateStatistics(QueryParser qp) {
        PreparedStatementCreator preparedStatementCreator = getPreparedStatementCreator(qp);
        PreparedStatementSetter preparedStatementSetter = getPreparedStatementSetter(qp);
        ResultSetExtractor<Map<String, Long>> resultSetExtractor = getResultSetExtractor();
        return jdbcTemplate.query(preparedStatementCreator, preparedStatementSetter, resultSetExtractor);
    }

    private PreparedStatementCreator getPreparedStatementCreator(QueryParser queryParser) {
        return new PreparedStatementCreator() {
            @Override
            public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
                // build the sql query
                StringBuilder selectStatement = new StringBuilder();
                selectStatement.append("SELECT CASE ");
                for (int i = 0; i < intervalsMins.length; i++) {
                    selectStatement
                            .append(String
                                    .format("WHEN (time > (current_timestamp - interval '%d minutes')) THEN '%d' ",
                                            intervalsMins[i], i));
                }
                selectStatement.append(" END as ident ");

                // concatenate sql with the CASE statement
                String query = "SELECT ident, count(ident) as cnt FROM ("
                        + selectStatement + " FROM test t "
                        + "LEFT JOIN network_type nt ON nt.uid=t.network_type"
                        + " LEFT JOIN device_map adm ON adm.codename=t.model"
                        + " LEFT JOIN test_server ts ON ts.uid=t.server_id"
                        + " LEFT JOIN provider prov ON provider_id = prov.uid "
                        + " LEFT JOIN provider mprov ON mobile_provider_id = mprov.uid"
                        + " WHERE" + " t.deleted = false"
                        + " AND status = 'FINISHED' " + queryParser.getWhereClause("AND")
                        + " AND time > (current_timestamp - interval '"
                        + intervalsMins[intervalsMins.length - 1] + " minutes'" + ")"
                        + ") a GROUP BY ident ORDER BY ident ASC;";

                return con.prepareStatement(query);
            }
        };
    }

    private PreparedStatementSetter getPreparedStatementSetter(QueryParser queryParser) {
        return new PreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps) throws SQLException {
                queryParser.fillInWhereClause(ps, 1);
            }
        };
    }

    private ResultSetExtractor<Map<String, Long>> getResultSetExtractor() {
        return new ResultSetExtractor<Map<String, Long>>() {
            @Override
            public Map<String, Long> extractData(ResultSet rs) throws SQLException, DataAccessException {
                Map<String, Long> map = new HashMap<>();
                INTERVAL_LABELS_MAP.values()
                        .forEach(label -> map.put(label, 0L));
                long tests = 0;
                while (rs.next()) {
                    int interval = intervalsMins[rs.getInt("ident")];
                    tests += rs.getLong("cnt");
                    String label = INTERVAL_LABELS_MAP.get(interval);
                    map.put(label, tests);
                }
                return map;
            }
        };
    }
}
